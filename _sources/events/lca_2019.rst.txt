=======================================
linux.conf.au Christchurch January 2019
=======================================

Monday Jan 21
~~~~~~~~~~~~~

Toolmaking
----------
Julien Goodwin

-  in your tool set have simple examples for future work

   -  real, but simple uses of libraries

-  toolkit for later uses

   -  things you can plumb together are great

-  write using whatever tool makes sense and/or you know

   -  choose one or two as a primary so you get better at it, and you can share
      with others in your shop (i.e. try to standardize)

-  keep shell scripts to a few dozen lines at most
-  for other limits, no inherent limit, but use sensible modularity and testing
-  testing

   -  testing large operation tools can be hard
   -  splitting elements into testable modules, with their own fake
      implementations for larger system tests can work well
   -  try to keep a standard, shared library constants

-  for any tool you will use more than once, also write some documentation

   -  at the minimum this means code comments or a CLI help output

-  do some input validation (doesn't have to be perfect, but some basic checks are good)

   -  catching gross errors and bailing with a usage message is fine

-  distribution

   -  no personal tools for team problems
   -  have a way to distribute so all team members can run and update

-  for many ops teams having a single toolmaking-focused engineer is a great idea

   -  but a separate team of toolmakers is often bad
   -  if scaling to a separate team have that team work on supporting infrastructure
   -  in other words, the people that use the tool should be involved in making the tool

Python: Bringing your code to the next level
--------------------------------------------
Jan Groth

-  use Python 3
-  use a tool to manage environments and use a dedicated environment for each project
-  aim for readability

   -  use coding conventions
   -  use descriptive file names
   -  use descriptive names within code and don't rely on comments
   -  break into methods

-  aim for beautiful code

   -  use the language construct that fits best

      -  e.g. use list comprehension instead of a for loop

   -  comment the why, not the what

-  don't separate behavior and state: use classes as a blueprint for objects
   to capture state as well as behavior (methods)

   -  re-use code elsewhere
   -  use inheritance
   -  write unit tests

-  use an IDE

What the dep is going on with Go dependency management?
-------------------------------------------------------
Adam Harvey

-  several dependency management tools have come out over time
-  Go 1.12 (next stable release) will ship ``go mod`` as the default package manager
-  ``go mod`` requires semantic versioning

Developer Developer Lightning Talks
-----------------------------------
Adam Harvey

-  `Valgrind <http://valgrind.org/>`_ automatically detects many memory
   management and threading bugs, and profiles programs in detail

-  useful for languages without automatic memory management such as C, C++, and Rust

Brenda Wallace

-  When they publish a law, they publish a reference implementation in Python
   (with unit tests)

-  When the law changes, they can run the tests and if it breaks they can fix the law
-  `rules.nz <http://www.rules.nz/>`_

How Much Do You Trust That Package? Understanding The Software Supply Chain
---------------------------------------------------------------------------
Benno Rice

-  Supply chain issues

   -  package source tampering
   -  malware
   -  availability (bugs in or unavailability of delivery mechanisms)
   -  defects (aka code bugs)
   -  lack of maintenance

-  Mitigation

   -  support the maintainers
   -  have a management process for third-party dependencies
   -  have an upgrade/update process
   -  have a process to review/audit third-party code

Automated firewall testing
--------------------------
Kristof Provost

-  maintainer of ``pf``, a packet filter (aka firewall) in freeBSD
-  why automated testing?

   -  make sure things actually work
   -  convenient test case
   -  prevent regressions
   -  sanity check when making changes

-  tests should be:

   -  easy to write
   -  easy for everyone to run
   -  fast to run
   -  integrate with existing test framework

-  ``vnet`` is a virtual networking stack you can run tests against
-  ``jail`` isolates the environment in a container

Clockwork: Programming with rules
---------------------------------
Mike O'Connor

-  language for programming custom industrial machines

-  issues:

   -  long term custom hardware support is hard
   -  commercial solutions use binary file formats for source configuration

-  requirements:

   -  retain control
   -  reduce risk
   -  be future-proof
   -  reuse don't rewrite
   -  version control all source code

-  Result:

   -  simple programming language
   -  program pieces are called ``machines``
   -  machine can be simulated easily
   -  a machine state resembles a physical machine state
   -  reduces risk by programming in house, simulating as developing, reusing
      what was done before
   -  future-proof by using Linux and open source software
   -  version control everything
   -  effective debugging tools

-  Clockwork

   -  latproc language
   -  objects are ``machines``
   -  describe machines by states
   -  surrounding tools (shell, control daemon, interpreter, sampler, etc.)
